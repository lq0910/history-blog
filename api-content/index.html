{"posts":[{"title":"ES6语法学习","content":"ps：ES5之后的JS语法统称ES6！！！ 一、关于取值的吐槽 取值在程序中非常常见，比如从对象obj中取值。 const obj = { a:1, b:2, c:3, d:4, e:5, } 复制代码 吐槽： const a = obj.a; const b = obj.b; const c = obj.c; const d = obj.d; const e = obj.e; 复制代码 或者 const f = obj.a + obj.d; const g = obj.c + obj.e; 复制代码 吐槽：“不会用ES6的解构赋值来取值吗？5行代码用1行代码搞定不香吗？直接用对象名加属性名去取值，要是对象名短还好，很长呢？搞得代码中到处都是这个对象名。” 改进： const {a,b,c,d,e} = obj; const f = a + d; const g = c + e; 复制代码 反驳 不是不用ES6的解构赋值，而是服务端返回的数据对象中的属性名不是我想要的，这样取值，不是还得重新创建个遍历赋值。 吐槽 看来你对ES6的解构赋值掌握的还是不够彻底。如果想创建的变量名和对象的属性名不一致，可以这么写： const {a:a1} = obj; console.log(a1);// 1 复制代码 补充 ES6的解构赋值虽然好用。但是要注意解构的对象不能为undefined、null。否则会报错，故要给被解构的对象一个默认值。 const {a,b,c,d,e} = obj || {}; 复制代码 二、关于合并数据的吐槽 比如合并两个数组，合并两个对象。 const a = [1,2,3]; const b = [1,5,6]; const c = a.concat(b);//[1,2,3,1,5,6] const obj1 = { a:1, } const obj1 = { b:1, } const obj = Object.assgin({}, obj1, obj2);//{a:1,b:1} 复制代码 吐槽 ES6的扩展运算符是不是忘记了，还有数组的合并不考虑去重吗？ 改进 const a = [1,2,3]; const b = [1,5,6]; const c = [...new Set([...a,...b])];//[1,2,3,5,6] const obj1 = { a:1, } const obj2 = { b:1, } const obj = {...obj1,...obj2};//{a:1,b:1} 复制代码 三、关于拼接字符串的吐槽 const name = '小明'; const score = 59; const result = ''; if(score &gt; 60){ result = ${name}的考试成绩及格; }else{ result = ${name}的考试成绩不及格; } 复制代码 吐槽 像你们这样用ES6字符串模板，还不如不用，你们根本不清楚在中可以做什么操作。在{}中可以做什么操作。在中可以做什么操作。在{}中可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 改进 const name = '小明'; const score = 59; const result = ${name}${score &gt; 60?'的考试成绩及格':'的考试成绩不及格'}; 复制代码 四、关于if中判断条件的吐槽 if( type == 1 || type == 2 || type == 3 || type == 4 || ){ //... } 复制代码 吐槽 ES6中数组实例方法includes会不会使用呢？ 改进 const condition = [1,2,3,4]; if( condition.includes(type) ){ //... } 复制代码 五、关于列表搜索的吐槽 在项目中，一些没分页的列表的搜索功能由前端来实现，搜索一般分为精确搜索和模糊搜索。搜索也要叫过滤，一般用filter来实现。 const a = [1,2,3,4,5]; const result = a.filter( item =&gt;{ return item === 3 } ) 复制代码 吐槽 如果是精确搜索不会用ES6中的find吗？性能优化懂么，find方法中找到符合条件的项，就不会继续遍历数组。 改进 const a = [1,2,3,4,5]; const result = a.find( item =&gt;{ return item === 3 } ) 复制代码 六、关于扁平化数组的吐槽 一个部门JSON数据中，属性名是部门id，属性值是个部门成员id数组集合，现在要把有部门的成员id都提取到一个数组集合中。 const deps = { '采购部':[1,2,3], '人事部':[5,8,12], '行政部':[5,14,79], '运输部':[3,64,105], } let member = []; for (let item in deps){ const value = deps[item]; if(Array.isArray(value)){ member = [...member,...value] } } member = [...new Set(member)] 复制代码 吐槽 获取对象的全部属性值还要遍历吗？Object.values忘记了吗？还有涉及到数组的扁平化处理，为啥不用ES6提供的flat方法呢，还好这次的数组的深度最多只到2维，还要是遇到4维、5维深度的数组，是不是得循环嵌套循环来扁平化？ 改进 const deps = { '采购部':[1,2,3], '人事部':[5,8,12], '行政部':[5,14,79], '运输部':[3,64,105], } let member = Object.values(deps).flat(Infinity); 复制代码 其中使用Infinity作为flat的参数，使得无需知道被扁平化的数组的维度。 补充 flat方法不支持IE浏览器。 七、关于获取对象属性值的吐槽 const name = obj &amp;&amp; obj.name; 复制代码 吐槽 ES6中的可选链操作符会使用么？ 改进 const name = obj?.name; 复制代码 八、关于添加对象属性的吐槽 当给对象添加属性时，如果属性名是动态变化的，该怎么处理。 let obj = {}; let index = 1; let key = topic${index}; obj[key] = '话题内容'; 复制代码 吐槽 为何要额外创建一个变量。不知道ES6中的对象属性名是可以用表达式吗？ 改进 let obj = {}; let index = 1; obj[topic${index}] = '话题内容'; 复制代码 九、关于输入框非空的判断 在处理输入框相关业务时，往往会判断输入框未输入值的场景。 if(value !== null &amp;&amp; value !== undefined &amp;&amp; value !== ''){ //... } 复制代码 吐槽 ES6中新出的空值合并运算符了解过吗，要写那么多条件吗？ if(value??'' !== ''){ //... } 复制代码 十、关于异步函数的吐槽 异步函数很常见，经常是用 Promise 来实现。 const fn1 = () =&gt;{ return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 300); }); } const fn2 = () =&gt;{ return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2); }, 600); }); } const fn = () =&gt;{ fn1().then(res1 =&gt;{ console.log(res1);// 1 fn2().then(res2 =&gt;{ console.log(res2) }) }) } 复制代码 吐槽 如果这样调用异步函数，不怕形成地狱回调啊！ 改进 const fn = async () =&gt;{ const res1 = await fn1(); const res2 = await fn2(); console.log(res1);// 1 console.log(res2);// 2 } 复制代码 补充 但是要做并发请求时，还是要用到Promise.all()。 const fn = () =&gt;{ Promise.all([fn1(),fn2()]).then(res =&gt;{ console.log(res);// [1,2] }) } 复制代码 如果并发请求时，只要其中一个异步函数处理完成，就返回结果，要用到Promise.race()。 ","link":"https://lq0910.github.io/post/es6-yu-fa-xue-xi/"},{"title":"H5移动端CSS横向滚动实现","content":"方案一 HMTL &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS overflow-x: scroll; overflow-y: hidden; white-space: nowrap; -webkit-overflow-scrolling: touch; 🔔在线代码示例 ","link":"https://lq0910.github.io/post/h5-yi-dong-duan-css-heng-xiang-gun-dong-shi-xian/"},{"title":"geojson-to-kml geojson导出kml","content":"This is a fork of mapbox/tokml. geojson-to-kml Convert GeoJSON to KML. Usage with node npm install --save geojson-to-kml Example import tokml from &quot;geojson-to-kml&quot;; // kml is a string of KML data, geojsonObject is a JavaScript object of // GeoJSON data const kml = tokml(geojsonObject); // grab name and description properties from each object and write them in // KML const kmlNameDescription = tokml(geojsonObject, { name: &quot;name&quot;, description: &quot;description&quot; }); // name and describe the KML document as a whole const kmlDocumentName = tokml(geojsonObject, { documentName: &quot;My List Of Markers&quot;, documentDescription: &quot;One of the many places you are not I am&quot; }); API tokml(geojsonObject, [options]) Given GeoJSON data as an object, return KML data as a string of XML. options is an optional object that takes the following options: The property to name/description mapping: while GeoJSON supports freeform properties on each feature, KML has an expectation of name and description properties that are often styled and displayed automatically. These options let you define a mapping from the GeoJSON style to KML's. name: the name of the property in each GeoJSON Feature that contains the feature's name description: the name of the property in each GeoJSON Feature that contains the feature's description Timestamp: KML can associate features with a moment in time via the TimeStamp tag. GeoJSON doesn't have a comparable field, but a custom property can be mapped timestamp: the name of the property in each GeoJSON Feature that contains a timestamp in XML Schema Time (yyyy-mm-ddThh:mm:sszzzzzz) Document name and description: KML supports name and description properties for the full document. documentName: the name of the full document documentDescription: the description of the full document simplestyle-spec support: simplestyle: set to true to convert simplestyle-spec styles into KML styles Development Requires node.js. install npm install test npm test build npm run build ","link":"https://lq0910.github.io/post/geojson-to-kml-geojson-dao-chu-kml/"},{"title":"QGIS OSGeo4W 国内镜像源急速下载","content":"🚩注意：本仓库手动同步，不保证所有内容是最新的！ 使用方法 打开 OSGeo4W Setup ，在 “Choose A Download Site” 页面的 User URL 中输入地址 http://gwmodel.whu.edu.cn/mirrors/osgeo4w ，点击 Add 按钮，然后选择该镜像进行安装 osgeo4w-setup-x86_64 下载 🔗 ","link":"https://lq0910.github.io/post/qgis-osgeo4w-guo-nei-jing-xiang-yuan-ji-su-xia-zai/"},{"title":"pip安装opencv-python 国内阿里云源","content":"安装 opencv-python 使用国内源 -i https://mirrors.aliyun.com/pypi/simple/ pip install opencv-python -i https://mirrors.aliyun.com/pypi/simple/ ","link":"https://lq0910.github.io/post/pip-an-zhuang-opencv-python-guo-nei-a-li-yun-yuan/"},{"title":"Aurelia 好用强大的前端mvvm框架 ","content":"👏 推荐一款前端框架 Aurelia ！ ✍️ Aurelia 一个简单功能强大的mvvm前端框架 基于TypeScript 构建组件的框架 ... ... Github Aurelia 官网 文档 特性👇 📝 易于学习 Aurelia 基于标准的风格使它成为唯一允许您使用原生 JavaScript 或 TypeScript 构建组件的框架。如果您了解现代 JS 和 HTML，那么构建最复杂的应用也没有什么需要学习的了。 🌉 高性能 Aurelia 的核心是高性能的响应式系统，能够以将其他框架及其虚拟 DOM 留给灰尘的方式批处理 DOM 更新。无论您的 UI 多么复杂，都体验一致、可扩展的性能。 🏷️ 双向数据绑定 Aurelia 支持对任何对象进行强大的数据绑定。通过使用自适应技术，Aurelia 选择最有效的方法来观察模型中的每个属性，并自动同步 UI 和状态，并实现一流的性能。 📋 路由、组合和渐进增强 利用 Aurelia 的高级客户端路由器及其可插拔管道和子路由器。不需要路由器，但需要动态的数据驱动 UI 组合？我们也这样做。有旧版应用？Aurelia 的渐进式增强和脚本标记构建也使得我们很容易逐步采用。 💻 使用约定轻松编码 通过约定，您可以专注于代码和业务逻辑。Aurelia 是当今唯一将代码位于应用中心而不是框架的框架。 🌱 团队已经过多年实践，框架强烈推荐，只是目前国内使用的团队和开发者比较少，没有三大框架那么火，希望有一天aurelia可以火起来吧，让更多开发者加入🏃 未来，它一定会成为你离不开的伙伴 强烈建议体验喔！ 😘 Enjoy~ ","link":"https://lq0910.github.io/post/aurelia-hao-yong-qiang-da-de-qian-duan-mvvm-kuang-jia/"}]}